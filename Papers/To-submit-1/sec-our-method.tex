\section{Our technique}

\subsection{Protocols}

We suggest a \clos{}-based \emph{protocol} defining the set of
operations on a buffer.  In fact, the protocol can be divided into
three fairly-independent protocols:

\begin{itemize}
\item An external protocol for interacting with the contents of a
  single line.  This protocol contains functions for inserting and
  deleting items in a line, for obtaining items and item count in a
  line, and also for manipulating the \emph{cursor} abstraction.
\item An external protocol for interacting with the contents of the
  buffer as a whole.  This protocol contains functions for inserting
  and deleting lines in the buffer, and for querying the line count
  and item count of the entire buffer.
\item An internal protocol that manages the interaction between the
  line abstraction and the buffer abstraction.
\end{itemize}

\subsection{Supplied implementations}

For the \emph{line protocol}, we supply two different implementations,
the \emph{standard line} implementation and the \emph{simple line}
implementation.  Similarly, for the \emph{buffer protocol}, we supply
two different implementations, the \emph{standard buffer} implementation
and the \emph{simple buffer} implementation.

\subsubsection{Standard line implementation}

The standard line implementation is the one that a typical application
would always use, unless an application-specific line implementation
is desired.

To appreciate the design of the standard line, we need to distinguish
between two different \emph{categories} of operations on a line.  We
call these categories \emph{editing operations} and \emph{contents
  queries}, respectively.  An editing operation is one in which the
contents of the line is modified in some way, and is the result of the
interaction of a user typing text, inserting or removing a
\emph{region} of text, or executing a \emph{keyboard macro} that
results in one or more editing operations.  A contents query happens
as a result of an \emph{event loop} or a \emph{command loop} updating
one or more \emph{views} of the contents.

A crucial observation related to these categories is that contents
queries are the result of \emph{events}; typically the user typing
text or executing commands.  The frequency of such events is fairly
low, giving us ample time to satisfy such a query.  Editing
operations, on the other hand, can be arbitrarily more frequent,
simply because a single keystroke on the part of the user can trigger
a very large number of editing operations.%
\footnote{It is of course possible to supply \emph{aggregate}
  operations that alleviate the problem of frequent editing
  operations.  In particular, it is possible to supply operations that
  insert a \emph{sequence} of items, and that delete a \emph{region}
  of items.  However, such operations complicate the implementations
  of the protocol.  Worse, there are still cases where many simple
  editing operations need to be executed, in particular as a result of
  executing keyboard macros.}

This implementation supplies two different representations of the line
that we call \emph{open} and \emph{closed} respectively.  An line is
\emph{open} if the last operation on it was an editing operation.  It
is \emph{closed} if the last operation was a contents query in the
form of a call to the generic function \texttt{items}.  Accordingly, a
line is changed from being open to being closed whenever there is a
contents query, and from closed to open when there is call to an
editing operation.

A closed line is represented as a \commonlisp{} simple vector.  An
open line is represented as a gap buffer. \seesec{sec-previous-work}
The protocol specifically does not allow for the caller of a contents
query to modify the vector returned by the query.  This restriction
allows us to return the same vector each time there is a contents
query without any intervening editing operation, thus making it
efficient for views to query closed lines repeatedly.  Similarly,
repeated editing operations maintain the line open, making such a
sequence of operations efficient as well.

Clearly, the typical use case when a user issues keystrokes, each one
resulting in a simple editing operation such as inserting or deleting
an item, followed by an update of one or more views of the buffer
contents is not terribly efficient.  The reason is that this use case
results in a line being alternately opened (as a result of the editing
operation) and closed (as a result of the view update) for each
keystroke.  However, this use case does not have to be very efficient,
again because it all happens at the frequency of the event loop.  The
use case for which the standard line design was optimized is the one
where a single keystroke results in several simple editing operations,
which is exactly when performance is crucial.

\subsubsection{Standard buffer implementation}

The main performance challenge for the buffer implementation is to
obtain acceptable performance in the presence of multiple views (into
a single buffer) that are fare apart, and that both issue editing
operations in each interaction.  The typical scenario would be a user
having two views, one close to the beginning of the buffer and one
close to the end of the buffer, while executing a keyboard macro that
deletes from one of the views and inserts in the other.

This time, the performance challenge has to do with the \emph{update
  protocol} rather than with the edit protocols.  A naive buffer
implementation would have to iterate over all the lines each time the
update protocol is invoked.

To obtain reasonable performance in the presence of multiple views,
the standard buffer implementation uses a \emph{splay tree}
\cite{Sleator:1985:SBS:3828.3835} with a node for each line in the
buffer.  A splay tree is a \emph{self adjusting} binary tree, in that
nodes that are frequently used migrate close to the root of the tree.
Although the typical use of splay trees and other tree types is to
serve as implementation of \emph{dictionaries}, an often overlooked
fact is that all trees can be used to implement \emph{editable
  sequences}, which is how we use the splay tree here.
