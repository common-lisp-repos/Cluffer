\section{Previous work}
\label{sec-previous-work}

\subsection{Representing items in a buffer}

There are two basic techniques for representing the items in an editor
buffer, namely \emph{gap buffer} and \emph{line oriented}.

\subsubsection{Gap buffer}
\label{sec-previous-gap-buffer}

A gap buffer can be thought of as a vector holding the items of the
buffer (typically characters) but with some additional free space.  In
a typical gap-buffer implementation, a possibly-empty \emph{prefix} of
the buffer contents is stored at the beginning of the vector, and a
possibly-empty \emph{suffix} of the contents is stored at the end of
the vector, leaving a possibly-empty \emph{gap} between the prefix and
the suffix.

Buffer items are moved from the end of the prefix to the beginning of
the suffix, and vice-versa, in order to position the gap where an item
is about to be inserted or deleted.  The typical use case for text
editing has a very high probability that two subsequent editing
operations will be \emph{close} to each other (in terms of the number
of items between the two.  Therefore, this data structure is very
efficient for editing operations in most cases.

Clearly, in the worst case, all buffer items must be moved for every
editing operation.  This case happens when editing operations
alternate between the beginning of the buffer and the end of the
buffer.  Even so, moving all the items even in a very large buffer
does not represent a serious performance problem.  Furthermore, the
pathological case can be largely avoided by considering the vector
holding the items as being \emph{circular} as Flexichain
\cite{flexichain} does.

Perhaps the main disadvantage of representing the entire buffer as a
single gap buffer is that it is difficult to associate additional
information with specific points in the buffer.  One might, for
instance, want to associate some state of an \emph{incremental parser}
that keeps track of the buffer contents in a more structured form.

Another difficulty with the gap-buffer representation has to do with
updating possibly multiple \emph{views}.  As we discussed in
\refSec{sec-introduction}, views are updated at the frequency of the
event loop, whereas the manipulation of \emph{regions} of items and
especially the use of \emph{keyboard macros} may make the frequency of
editing operations orders of magnitude higher.

\subsubsection{Line oriented}
\label{sec-previous-line-oriented}

Another common way of representing the editor buffer recognizes that
text is usually divided into \emph{lines}, where each line typically
has a very moderate number of items (typically characters) in it.

In a line-oriented representation, we are dealing with a
\emph{two-level sequence}.  At the outer level, we have a sequence of
lines, and each element of that sequence is a sequence of items.
Every possible combination of representations of these two sequences
is possible.  However, since the number of items in an individual line
is usually small, most existing editors do not go to great lengths to
optimize the representation of individual lines.  Furthermore, while
the number of lines in a buffer is typically significantly greater
than the number of items in a line, a typical buffer may contain at
most a few thousand lines, making the representation of the outer
sequence fairly insignificant as well.

Perhaps the main disadvantage of a line-oriented representation
compared to a gap-buffer representation is that transferring items to
and from a file is slower.  With a gap-buffer representation, the
representation in memory and the representation in a file are very
similar, making the transfer almost trivial.  With a line-oriented
representation, when a buffer is created from the contents of a file,
each line separator must be handled by the creation of a new
representation of a line.

However, with modern processors, the time to load and store a buffer
is likely to be dominated by the input/output operations.
Furthermore, the number of lines in a typical buffer is typically very
modest.  For that reason, a line-oriented representation does not
incur any serious performance penalty compared to a gap buffer.

\subsection{Existing editors}

\subsubsection{GNU Emacs}

GNU Emacs \cite{GNUEmacsLispReferenceManual}
\cite{CraftOfTextEditiing} uses a \emph{gap buffer} for the entire
buffer of text as described in \refSec{sec-previous-gap-buffer}.

When GNU Emacs was designed, the main issue with updating a view was
to minimize the number of bytes that had to be sent to a CRT terminal.
To accomplish this optimization, the \emph{redisplay} function
compared the previous view to the next one, and attempted to issue
terminal-specific editing operations to turn the screen contents into
the updated version.  Of course, most of the time, the task consisted
of positioning the cursor and inserting a single character.

Today, there is no need to minimize the number of editing operations
on a terminal; it is perfectly feasible to redraw the entire view for
each iteration of the event loop.  However, today we have many more
requirements on a text editor.  In the most advanced cases, we would
like for an \emph{incremental parser} in the view to keep a structured
version of the buffer contents, for various purposes, such as syntax
highlighting, language-specific completion and parsing, etc.  An
incremental parser may require considerable computing power.  It is
therefore of utmost importance that as little work as possible is done
each time around the event loop.  Representing the entire editor
buffer as a gap buffer does not lend itself to such advanced
incremental processing.

\subsubsection{Multics Emacs}


Multics Emacs%
\footnote{The description in this section is a summary of the
  information found here: http://www.multicians.org/mepap.html}
was the first Emacs implementation written in \lisp{}, in this case
\multics{} \maclisp{}.  In therefore pre-dates GNU Emacs.

Multics Emacs used a doubly-linked list of lines and each line was a
sequence of characters.  Special instructions were added to the GE
645...

\subsubsection{Climacs}

Like GNU Emacs, Climacs uses a gap buffer for the entire buffer.  It
avoids the bad case by using a circular buffer.  In fact, it uses
Flexichain \cite{flexichain}.

\subsubsection{Others}

Hemlock, Goatee, etc.

